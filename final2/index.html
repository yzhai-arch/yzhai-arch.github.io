<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fixed Maze Prototype</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/addons/p5.dom.min.js"></script>

<script>



let currentRoom = "room3";
let bgImg;
let leftOpenImg, midOpenImg, rightOpenImg;
let safeEyeImg = null;
let kindEyeImg = null;
let burningOverlayImg = null;
let fakeEndingVideos = {};
let fakeEndingReady = {};
let fakeEndingState = null;
let eatMiceVideo = null;
let eatMiceVideoReady = false;
let eatMiceEndingState = null;
let becomemiceVideo = null;
let becomemiceVideoReady = false;
let becomemiceEndingState = null;
let transitionState = "idle"; 
// idle | video

let transitionStartTime = 0;
let clickedDoor = null;

let doorVideos = {};
let videoReady = {};
let activeVideo = null;
let activeDoorType = null;
let roomScale = 1;
let roomAlpha = 255;
const DOOR_OPEN_SOUND = "opendoor.wav";
const MAX_NO_ENDING_CLICKS = 6;
const FAKE_ENDING_OVERLAY_TEXT =
  "You gain nothing except freedom...Now, you have to live your poor life again like what you've did before...But you kept seeing something in your eye....";
const FAKE_ENDING_RETURN_DELAY = 8000;
const FAKE_ENDING_RETURN_MESSAGE = "you went back to the room...Or did you even got out...?";
const EAT_MICE_MESSAGE = "You got lost and now you can only eat mice in order to survive...";
const BECOME_MICE_MESSAGE = "You ate tooooooo many mice and you became one of THEM.....You've became very furrryyyyy";
const BECOME_MICE_THRESHOLD = 3;
const CAMERA_OVERLAY_TEXT =
  "We Finnaly found the hand behide all this... pain!!! And the person is in the art industry!!!! OMG the person is even in risd.... IT'S RISD that is behide all of this!!!!";

let fallingStars = [];
const STAR_COUNT = 45;

let isDeathScreen = false;
let restartHover = false;
let undefinedDoorStreak = 0;
let consecutiveNoEndingClicks = 0;
let proceduralRoomCounter = 0;
let sequentialDoorTransitions = 0;
let eatMiceEndingCount = 0;
let midDoorFakegroundArmed = false;
let lastDoorDirection = null;
let cameraCapture = null;
let cameraCaptureReady = false;
let cameraOverlayActive = false;
let cameraMosquitoes = [];
const deathMessageRib = "You fell into empty and broke your rib and died";
const deathMessageArm = "You fell into emptiness and tried to grab something but you failed while twitched your arm, now you die with a broken arm.";
const deathMessageCold = "Who built this place...e...E...EEE...AHHHHHHHHHHHHHHHHHHHH.........(you died)";
const deathMessageFly = "You stepped on air and tried to fly but you don't have wings nether are you magnetic levitational train...YOU DIED";
const deathMessageFloat = "OHHHH you really started to love the feeling of flying through air didn't you, or else why would you die so often...lets go straight next time....";
const deathMessageMosquito = "Sometimes I hate flies but THEY CAN FLY...I wish I could be sucked by millions of mosquitoes so I can fly and don't need to fall into emptiness...AGAIN!";
const deathMessageLongFall = "Your feet can't touch the ground for now but you will soon .......................(You died after falling for 20 minutes)";
const deathMessageNoooo = "NOOOOOOOOOOOOOOOOOOOOOooooooooooo..............(You Died)";
let deathMessageText = deathMessageRib;
const restartButton = { x: 0, y: 0, w: 240, h: 48 };

let nextRoom = null;
let nextRoomBg = null;
let transitionOrigin = null;
let specialRoomStartTime = null;
let overlayMessage = null;
let introVideo;
let introVideoReady = false;
let introState = "video";
let introDialogIndex = 0;
let introFadeStart = null;
let introBlackScreenStart = null;
const VIDEO_SPEED = 0.85;
const VIDEO_FALLBACK_DURATION = 2200;
const ZOOM_OUT_SCALE = 2.4;
const NEW_ROOM_SCALE_START = 0.72;
const DOOR_VIDEO_SOURCES = {
  front: "midopen.mp4",
  left: "leftopen.mp4",
  right: "rightopen.mp4"
};
const SPECIAL_ROOM_ID = "room3_2_void";
const OVERLAY_FADE = 400;
const OVERLAY_HOLD = 2200;
const OVERLAY_TEXT = "Ohmy that's so kind hearted of her...but where is my position...";
const BURNING_ROOM_ID = "room8_3";
const BURNING_ROOM_MESSAGE =
  "You stepped into an incinerator...before your brain get's boiled out.... you knew where the snow are from now..W.WWWWWWAWWAWAW(YOU DIED)";
const FAKE_ENDING_VIDEO_SOURCES = {
  fakeground: "fakeground.mp4",
  fakesun: "fakesun.mp4"
};
const INTRO_DIALOGUES = [
  "Light leaks through the cracks and your eyes adjust slowly.",
  "A distant hum whispers promises of warmth you never gained when you remembered all your mistakes.",
  "You, a prisioner, wishes for the true end for you misery, accidentally fell into a hole",
  "How unlucky of you...but how lucky, trust the wisper will you be free",
  "You opened your eyes, tring to find the path..."
];






function preload() {
  bgImg = loadImage("noopen.png");
  leftOpenImg = loadImage("leftopen.png");
  midOpenImg = loadImage("midopen.png");
  rightOpenImg = loadImage("rightopen.png");
  burningOverlayImg = loadImage(
    "burning.png",
    () => {},
    () => {
      console.warn("burning.png missing");
      burningOverlayImg = null;
    }
  );
  safeEyeImg = loadImage(
    "safeeye.GIF",
    () => {},
    () => {
      console.warn("safeeye.GIF missing");
      safeEyeImg = null;
    }
  );
  kindEyeImg = loadImage(
    "kindeye.GIF",
    () => {},
    () => {
      console.warn("kindeye.GIF missing");
      kindEyeImg = null;
    }
  );
}
/* =========
   迷宫结构
   ========= */
const rooms = {
  room3:    { left: "room2_1", front: "room3_2", right: "room4_1",   color: "#222" },
  room3_2:  { left: SPECIAL_ROOM_ID, front: "room3_1", right: "room4_2", color: "#222" },
  room2_1:  { left: "room2_1", front: "room3",   right: "room2_1", color: "#331111" },
  room3_1:  { left: "room3_1", front: "room3_1", right: "room3",   color: "#113333" },
  room4:    { left: "room3",   front: "room4",   right: "room4",   color: "#332211" },
  room4_1:  { left: "room4_1", front: "room4", right: "room4_1", color: "#2a1a1a" },
  room4_2:  { left: "room4_3", front: "room3_2", right: "room4",   color: "#222" },
  room4_3:  { left: "room4_3", front: "room3_2", right: "room5_3", color: "#222" },
  room5_3:  { left: SPECIAL_ROOM_ID, front: "room6_3", right: "room5_restart", color: "#222" },
  room5_restart: { left: "room3", front: "room3", right: "room3", color: "#000000" },
  room6_3:  { left: "room6_restart_left", front: "room7_3", right: "room6_restart_right", color: "#222" },
  room6_restart_left: { left: "room3", front: "room3", right: "room3", color: "#000000" },
  room6_restart_right: { left: "room3", front: "room3", right: "room3", color: "#000000" },
  room7_3:  { left: SPECIAL_ROOM_ID, front: BURNING_ROOM_ID, right: SPECIAL_ROOM_ID, color: "#222" },
  [BURNING_ROOM_ID]: { left: BURNING_ROOM_ID, front: BURNING_ROOM_ID, right: BURNING_ROOM_ID, color: "#331010" },
  [SPECIAL_ROOM_ID]: { left: SPECIAL_ROOM_ID, front: SPECIAL_ROOM_ID, right: SPECIAL_ROOM_ID, color: "#000000" }
};

let doors = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  currentBg = bgImg; // 默认背景
  initDoorVideo("front");
  initDoorVideo("left");
  initDoorVideo("right");
  initEatMiceVideo();
  initBecomeMiceVideo();
  initStarField();
  setupIntroVideo();
  initFakeEndingVideos();
}

function setupIntroVideo() {
  introVideo = createVideo("intro.mp4", () => {
    introVideoReady = true;
    introVideo.volume(0);
    introVideo.elt.muted = true;
    introVideo.elt.setAttribute("playsinline", true);
    introVideo.hide();
    introVideo.play();
  });
  introVideo.onended(() => {
    introState = "black";
    introBlackScreenStart = millis();
    if (introVideo) {
      introVideo.stop();
      introVideo.hide();
    }
  });
}

function initDoorVideo(type) {
  const src = DOOR_VIDEO_SOURCES[type];
  if (!src) return;
  videoReady[type] = false;
  doorVideos[type] = createVideo(src, () => handleVideoLoaded(type));
}

function handleVideoLoaded(type) {
  const vid = doorVideos[type];
  if (!vid) return;
  vid.volume(0);
  vid.elt.muted = true;
  vid.elt.setAttribute("playsinline", true);
  vid.hide();
  vid.stop();
  videoReady[type] = true;
}

function initFakeEndingVideos() {
  Object.keys(FAKE_ENDING_VIDEO_SOURCES).forEach(type => {
    const src = FAKE_ENDING_VIDEO_SOURCES[type];
    fakeEndingReady[type] = false;
    fakeEndingVideos[type] = createVideo(src, () => handleFakeEndingLoaded(type));
  });
}

function initEatMiceVideo() {
  eatMiceVideo = createVideo("eatmice.mp4", () => {
    eatMiceVideoReady = true;
    eatMiceVideo.volume(0);
    eatMiceVideo.elt.muted = true;
    eatMiceVideo.elt.setAttribute("playsinline", true);
    eatMiceVideo.hide();
    eatMiceVideo.stop();
  });
  eatMiceVideo.onended(() => {
    if (eatMiceEndingState) {
      eatMiceEndingState.phase = "black";
      eatMiceEndingState.endedAt = millis();
      eatMiceVideo.hide();
    }
  });
}

function initBecomeMiceVideo() {
  becomemiceVideo = createVideo("becomemice.mp4", () => {
    becomemiceVideoReady = true;
    becomemiceVideo.volume(0);
    becomemiceVideo.elt.muted = true;
    becomemiceVideo.elt.setAttribute("playsinline", true);
    becomemiceVideo.hide();
    becomemiceVideo.stop();
  });
}

function handleFakeEndingLoaded(type) {
  const vid = fakeEndingVideos[type];
  if (!vid) return;
  vid.volume(0);
  vid.elt.muted = true;
  vid.elt.setAttribute("playsinline", true);
  vid.hide();
  vid.stop();
  fakeEndingReady[type] = true;
}

function draw() {
  if (introState !== "done") {
    drawIntroSequence();
    return;
  }

  if (cameraOverlayActive) {
    drawCameraOverlay();
    drawOverlayMessage();
    return;
  }

  if (isDeathScreen) {
    drawDeathScreen();
    drawOverlayMessage();
    return;
  }

  if (becomemiceEndingState) {
    drawBecomeMiceEnding();
    drawOverlayMessage();
    return;
  }

  if (eatMiceEndingState) {
    drawEatMiceEndingScene();
    drawOverlayMessage();
    return;
  }

  if (fakeEndingState) {
    drawFakeEndingScene();
    drawOverlayMessage();
    return;
  }

  if (transitionState === "idle") {
    updateBackgroundOnHover();
    drawRoom();
    drawFallingStars(currentRoom);
    drawDoors();
  } 
  else {
    playTransition();
  }

  handleSpecialRoomTimer();
  drawOverlayMessage();
}
function playTransition() {
  let elapsed = millis() - transitionStartTime;
  const origin = getTransitionOrigin();

  // ===== Phase 1：播放视频 =====
  if (transitionState === "video") {
    if (!activeVideo) return;
    const duration = activeVideo.duration();
    const videoProgress = duration
      ? constrain(activeVideo.time() / duration, 0, 1)
      : constrain(elapsed / VIDEO_FALLBACK_DURATION, 0, 1);

    const scaleEase = 1 - pow(1 - videoProgress, 4);
    const newRoomEase = pow(videoProgress, 0.8);
    const fadeStart = 0.2;
    const fadeT = constrain((videoProgress - fadeStart) / (1 - fadeStart), 0, 1);
    const oldRoomAlpha = lerp(255, 0, fadeT);
    const newRoomAlpha = lerp(0, 255, videoProgress);

    const oldRoomScale = lerp(1, ZOOM_OUT_SCALE, scaleEase);
    const newRoomScale = lerp(NEW_ROOM_SCALE_START, 1, newRoomEase);

    // 旧房间：放大并淡出
    push();
    translate(origin.x, origin.y);
    applyDoorTurnTransform(activeDoorType, videoProgress, false);
    scale(oldRoomScale);
    tint(255, oldRoomAlpha);
    translate(-origin.x, -origin.y);
    drawRoom();
    drawFallingStars(currentRoom, oldRoomAlpha);
    pop();

    // 视频覆盖：与旧房间同步缩放/淡出
    push();
    translate(origin.x, origin.y);
    applyDoorTurnTransform(activeDoorType, videoProgress, false);
    scale(oldRoomScale);
    tint(255, oldRoomAlpha);
    translate(-origin.x, -origin.y);
    imageMode(CORNER);
    image(activeVideo, 0, 0, width, height);
    pop();

    // 新房间：从 0 逐渐显现
    if (nextRoomBg) {
      push();
      translate(origin.x, origin.y);
    applyDoorTurnTransform(activeDoorType, videoProgress, true);
    scale(newRoomScale);
    tint(255, newRoomAlpha);
    translate(-origin.x, -origin.y);
    drawRoomLayer(nextRoomBg);
    drawFallingStars(nextRoom, newRoomAlpha);
      pop();
    }

    if (videoProgress >= 1) {
      finishVideoTransition();
    }
  }
}

/* =========
   房间背景
   ========= */

function updateBackgroundOnHover() {
  if (currentRoom === SPECIAL_ROOM_ID) {
    currentBg = null;
    return;
  }
  if (currentRoom === BURNING_ROOM_ID) {
    currentBg = getRoomBaseBg(currentRoom);
    return;
  }
  currentBg = getRoomBaseBg(currentRoom); // 默认恢复当前房间底图

  for (let d of doors) {
    if (
      mouseX > d.x - d.w / 2 &&
      mouseX < d.x + d.w / 2 &&
      mouseY > d.y - d.h / 2 &&
      mouseY < d.y + d.h / 2
    ) {
      if (d.type === "left") currentBg = leftOpenImg;
      if (d.type === "front") currentBg = midOpenImg;
      if (d.type === "right") currentBg = rightOpenImg;
      break;
    }
  }
}
function drawRoom() {
  if (currentRoom === SPECIAL_ROOM_ID) {
    drawSpecialRoom();
  } else if (currentRoom === BURNING_ROOM_ID) {
    drawBurningIncineratorRoom();
  } else {
    drawRoomLayer(currentBg);
    drawRoomNarrative(currentRoom);
  }
}

function getTransitionOrigin() {
  if (transitionOrigin) return transitionOrigin;
  return { x: width / 2, y: height / 2 };
}

function getRoomBaseBg(roomId) {
  if (!roomId) return bgImg;
  if (roomId === SPECIAL_ROOM_ID) return null;
  return bgImg;
}

function getDoorOriginPoint(door) {
  if (!door) return { x: width / 2, y: height / 2 };
  if (door.type === "front") {
    return { x: width / 2, y: height / 2 };
  }
  return { x: door.x, y: door.y };
}

function drawRoomLayer(bgImage) {
  if (!bgImage) return;
  imageMode(CORNER);
  image(bgImage, 0, 0, width, height);
}

function drawSpecialRoom() {
  background(0);
  if (kindEyeImg) {
    push();
    imageMode(CENTER);
    tint(255, 140);
    let targetWidth = width * 0.7;
    let aspect = kindEyeImg.width && kindEyeImg.height ? kindEyeImg.height / kindEyeImg.width : 1;
    image(kindEyeImg, width / 2, height / 2 - 30, targetWidth, targetWidth * aspect);
    pop();
  } else if (safeEyeImg) {
    push();
    imageMode(CENTER);
    tint(255, 160);
    let targetWidth = width * 0.5;
    let aspect = safeEyeImg.width && safeEyeImg.height ? safeEyeImg.height / safeEyeImg.width : 1;
    image(safeEyeImg, width / 2, height / 2 - 40, targetWidth, targetWidth * aspect);
    pop();
  }
  drawCenteredParagraph(
    "Ohno, who had built such unsafe structure, my dear let me help you back to were you belong...",
    width / 2,
    height * 0.7,
    width * 0.65,
    height * 0.25,
    20,
    255
  );
}

function drawBurningIncineratorRoom() {
  drawRoomLayer(currentBg);
  const baseGlow = (sin(millis() * 0.01) + 1) / 2;
  push();
  rectMode(CORNER);
  fill(40 + baseGlow * 60, 0, 0, 180);
  rect(0, 0, width, height);
  pop();
  if (burningOverlayImg) {
    push();
    const scorch = 200 + baseGlow * 55;
    tint(255, scorch);
    imageMode(CORNER);
    image(burningOverlayImg, 0, 0, width, height);
    pop();
  }
  drawCenteredParagraph(
    BURNING_ROOM_MESSAGE,
    width / 2,
    height * 0.4,
    width * 0.75,
    height * 0.35,
    22,
    255
  );
  layoutBurningRestartButton();
  drawBurningRestartButton();
}

function drawFakeEndingScene() {
  background(0);
  const { type, video, start } = fakeEndingState || {};
  if (video && fakeEndingReady[type]) {
    drawVideoCover(video);
  } else {
    drawCenteredParagraph(
      "Waiting for the void to stitch a new scene...",
      width / 2,
      height / 2,
      width * 0.5,
      100,
      20,
      220
    );
  }
  const pulse = (sin(millis() * 0.003) + 1) / 2;
  drawCenteredParagraph(
    FAKE_ENDING_OVERLAY_TEXT,
    width / 2,
    height / 2,
    width * 0.6,
    160,
    20,
    200 + pulse * 55
  );
  layoutFakeEndingRestartButton();
  drawFakeEndingRestartButton();
  if (start && millis() - start >= FAKE_ENDING_RETURN_DELAY) {
    returnFromFakeEnding();
  }
}

function drawEatMiceEndingScene() {
  background(0);
  const { phase } = eatMiceEndingState || {};
  if (phase === "video" && eatMiceVideo && eatMiceVideoReady) {
    drawVideoCover(eatMiceVideo);
  }
  drawCenteredParagraph(
    EAT_MICE_MESSAGE,
    width / 2,
    height * 0.2,
    width * 0.7,
    150,
    20,
    240
  );
  if (phase === "black" || phase === "video_end") {
    layoutEatMiceRestartButton();
    drawEatMiceRestartButton();
  }
}

function drawBecomeMiceEnding() {
  background(0);
  if (becomemiceVideo && becomemiceVideoReady) {
    drawVideoCover(becomemiceVideo);
  }
  drawCenteredParagraph(
    BECOME_MICE_MESSAGE,
    width / 2,
    height * 0.2,
    width * 0.7,
    150,
    20,
    240
  );
  layoutEatMiceRestartButton();
  drawEatMiceRestartButton();
}

function drawFallingStars(roomId, starAlpha = 255) {
  if (roomId !== "room4_2" && roomId !== "room4_3" && roomId !== "room5_3" && roomId !== "room7_3") return;
  if (!fallingStars.length) {
    initStarField();
  }
  updateStarField();
  fill(255, starAlpha);
  noStroke();
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);
  for (let star of fallingStars) {
    textSize(star.size);
    text("*", star.x, star.y);
  }
}

function initStarField() {
  fallingStars = [];
  const density =
    currentRoom === "room7_3"
      ? STAR_COUNT * 4
      : currentRoom === "room5_3"
      ? STAR_COUNT * 3
      : currentRoom === "room4_3"
      ? STAR_COUNT * 2
      : STAR_COUNT;
  for (let i = 0; i < density; i++) {
    fallingStars.push(makeStar(true));
  }
}

function makeStar(initial = false) {
  return {
    x: random(width),
    y: initial ? random(-height, height) : random(-height, -20),
    speed: random(2, 5),
    size: random(12, 26),
    drift: random(-0.4, 0.4)
  };
}

function resetStar(star) {
  star.x = random(width);
  star.y = random(-height * 0.5, -20);
  star.speed = random(2, 5);
  star.size = random(12, 26);
  star.drift = random(-0.4, 0.4);
}

function updateStarField() {
  for (let star of fallingStars) {
    star.y += star.speed;
    star.x += star.drift;
    if (star.y - star.size > height) {
      resetStar(star);
    }
    if (star.x < -50) star.x = width + 30;
    if (star.x > width + 50) star.x = -30;
  }
}

function ensureCameraCapture() {
  if (cameraCapture) return;
  cameraCapture = createCapture({ video: true, audio: false }, () => {
    cameraCaptureReady = true;
  });
  cameraCapture.elt.setAttribute("playsinline", true);
  cameraCapture.hide();
}

function startCameraOverlay() {
  ensureCameraCapture();
  cameraOverlayActive = true;
  if (!cameraMosquitoes.length) {
    initCameraMosquitoes();
  }
}

function stopCameraOverlay() {
  cameraOverlayActive = false;
}

function initCameraMosquitoes() {
  cameraMosquitoes = [];
  const count = 36;
  for (let i = 0; i < count; i++) {
    cameraMosquitoes.push({
      x: random(width),
      y: random(height),
      size: random(16, 26),
      phase: random(TWO_PI),
      speed: random(0.002, 0.006)
    });
  }
}

function drawCameraOverlay() {
  background(0);
  if (cameraCapture && cameraCaptureReady) {
    drawVideoCover(cameraCapture);
  } else {
    drawCenteredParagraph(
      "Requesting the eye that watches everything...",
      width / 2,
      height / 2,
      width * 0.6,
      120,
      20,
      220
    );
  }
  drawCameraMosquitoes();
  drawCenteredParagraph(
    CAMERA_OVERLAY_TEXT,
    width / 2,
    height * 0.2,
    width * 0.8,
    200,
    22,
    255
  );
  drawCenteredParagraph(
    "(press SPACE to close)",
    width / 2,
    height * 0.85,
    width * 0.4,
    80,
    16,
    210
  );
}

function drawCameraMosquitoes() {
  if (!cameraMosquitoes.length) return;
  push();
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);
  const t = millis();
  for (let i = 0; i < cameraMosquitoes.length; i++) {
    const m = cameraMosquitoes[i];
    const sway = sin(t * m.speed + m.phase) * 8;
    const bob = cos(t * m.speed * 1.2 + m.phase) * 5;
    fill(255, 255, 255, 220);
    textSize(m.size);
    text("mosquito", m.x + sway, m.y + bob);
  }
  pop();
}

function applyDoorTurnTransform(doorType, progress, isNewRoom) {
  return;
}

/* =========
   门
   ========= */
function drawDoors() {
  doors = [];

  if (currentRoom === SPECIAL_ROOM_ID || currentRoom === BURNING_ROOM_ID) {
    return;
  }

  // 左门
  doors.push(drawDoor(
    width*0.15, height*0.57 + 10, 110, 190, "left"
  ));

  // 前门
  doors.push(drawDoor(
    width*0.5, height*0.55, 120, 180, "front"
  ));

  // 右门
  doors.push(drawDoor(
    width*0.85, height*0.57 + 10, 110, 190, "right"
  ));
}

function drawDoor(x, y, w, h, type) {
  push();
  noFill();
  noStroke();
  rectMode(CENTER);
  rect(x, y, w, h);
  pop();

  return { x, y, w, h, type };
}

/* =========
   点击交互
   ========= */
function mousePressed() {
  if (introState !== "done") {
    if (introState === "black") return;
    handleIntroClick();
    return;
  }

  if (cameraOverlayActive) {
    return;
  }

  if (isDeathScreen) {
    if (isInsideRestart(mouseX, mouseY)) {
      restartToRoom3();
    }
    return;
  }

  if (becomemiceEndingState) {
    if (isInsideRestart(mouseX, mouseY)) {
      restartToRoom3();
    }
    return;
  }

  if (eatMiceEndingState) {
    if (
      eatMiceEndingState.phase === "black" &&
      isInsideRestart(mouseX, mouseY)
    ) {
      restartToRoom3();
    }
    return;
  }

  if (fakeEndingState) {
    if (isInsideRestart(mouseX, mouseY)) {
      restartToRoom3();
    }
    return;
  }

  if (transitionState !== "idle") return;

  if (currentRoom === BURNING_ROOM_ID) {
    if (isInsideRestart(mouseX, mouseY)) {
      restartToRoom3();
    }
    return;
  }

  for (let d of doors) {
    if (
      mouseX > d.x - d.w / 2 &&
      mouseX < d.x + d.w / 2 &&
      mouseY > d.y - d.h / 2 &&
      mouseY < d.y + d.h / 2
    ) {
      clickedDoor = d;
      playDoorSound();
      if (midDoorFakegroundArmed && d.type === "front") {
        midDoorFakegroundArmed = false;
        startFakeEnding("fakeground");
        return;
      }
      if (random(1) < 0.3) {
        midDoorFakegroundArmed = false;
        startFakeEnding("fakesun");
        return;
      }
      const roomDef = rooms[currentRoom];
      if (!roomDef) continue;
      nextRoom = roomDef[d.type];
      if (!nextRoom) {
        midDoorFakegroundArmed = false;
        handleUndefinedDoorOutcome(d);
        return;
      }
      nextRoomBg = getRoomBaseBg(nextRoom);
      activeDoorType = d.type;
      transitionOrigin = getDoorOriginPoint(d);
      const deathMsg = getDeathMessage(currentRoom, d.type);
      if (deathMsg) {
        midDoorFakegroundArmed = false;
        consecutiveNoEndingClicks = 0;
        triggerDeathScreen(deathMsg);
        return;
      }
      consecutiveNoEndingClicks = 0;
      startDoorTransition(d.type);
      break;
    }
  }

}

function keyPressed() {
  if (key === " " && introState === "done") {
    if (cameraOverlayActive) {
      stopCameraOverlay();
    } else {
      startCameraOverlay();
    }
  }
}

function handleUndefinedDoorOutcome(doorRef) {
  midDoorFakegroundArmed = false;
  const type = random(1) < 0.5 ? "fakeground" : "fakesun";
  undefinedDoorStreak = 0;
  startFakeEnding(type);
}

function registerNonEndingClick() {
  consecutiveNoEndingClicks++;
  if (consecutiveNoEndingClicks >= MAX_NO_ENDING_CLICKS) {
    startEatMiceEnding();
    return true;
  }
  return false;
}

function createProceduralRoom() {
  const roomId = `void_room_${proceduralRoomCounter++}`;
  rooms[roomId] = {
    left: null,
    front: null,
    right: null,
    color: "#222"
  };
  return roomId;
}

function updateSequentialDoorCounter() {
  const roomDef = rooms[currentRoom];
  if (
    roomDef &&
    roomDef.left &&
    roomDef.front &&
    roomDef.right
  ) {
    sequentialDoorTransitions++;
  } else {
    sequentialDoorTransitions = 0;
  }
  if (sequentialDoorTransitions >= MAX_NO_ENDING_CLICKS) {
    startEatMiceEnding();
    sequentialDoorTransitions = 0;
  }
}

function startDoorTransition(doorDirection) {
  lastDoorDirection = doorDirection || activeDoorType || null;
  let chosenType = activeDoorType;
  if (!doorVideos[chosenType]) {
    chosenType = "front";
  }
  activeVideo = doorVideos[chosenType] || null;
  activeDoorType = chosenType;

  if (!activeVideo || !videoReady[chosenType]) {
    console.warn("door video 尚未加载完，先直接切换房间", activeDoorType);
    currentRoom = nextRoom;
    transitionState = "idle";
    activeVideo = null;
    activeDoorType = null;
    transitionOrigin = null;
    midDoorFakegroundArmed = lastDoorDirection === "left";
    lastDoorDirection = null;
    return;
  }

  transitionState = "video";
  transitionStartTime = millis();

  activeVideo.time(0);
  activeVideo.stop();
  activeVideo.speed(VIDEO_SPEED);
  activeVideo.play();
}

function finishVideoTransition() {
  if (activeVideo) activeVideo.stop();
  const usedDoor = lastDoorDirection;
  currentRoom = nextRoom;
  transitionState = "idle";
  roomScale = 1;
  roomAlpha = 255;
  nextRoomBg = null;
  activeVideo = null;
  activeDoorType = null;
  transitionOrigin = null;
  undefinedDoorStreak = 0;
  updateSequentialDoorCounter();
  midDoorFakegroundArmed = usedDoor === "left";
  lastDoorDirection = null;
}

function jumpDirectlyToRoom(roomId) {
  stopFakeEnding();
  stopEatMiceEnding();
  stopBecomeMiceEnding();
  midDoorFakegroundArmed = false;
  isDeathScreen = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  currentRoom = roomId;
  currentBg = getRoomBaseBg(currentRoom);
  transitionState = "idle";
  activeVideo = null;
  activeDoorType = null;
  nextRoom = null;
  transitionOrigin = null;
  specialRoomStartTime = null;
}

function goToNextRoom(direction) {
  const next = rooms[currentRoom][direction];
  if (next !== undefined) {
    currentRoom = next;
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  initStarField();
  if (cameraOverlayActive || cameraMosquitoes.length) {
    initCameraMosquitoes();
  }
}

function getDeathMessage(roomId, doorType) {
  if (roomId === "room2_1" && doorType === "left") {
    return deathMessageRib;
  }
  if (roomId === "room3_2" && doorType === "front") {
    return deathMessageArm;
  }
  if (roomId === "room4_2" && doorType === "front") {
    return deathMessageCold;
  }
  if (roomId === "room4_3" && doorType === "left") {
    return deathMessageArm;
  }
  if (roomId === "room4_3" && doorType === "front") {
    return deathMessageFly;
  }
  if (roomId === "room5_3" && doorType === "right") {
    return "How unlucky you decided to go right.... try to go front at this place the next time...";
  }
  if (roomId === "room4_2" && doorType === "right") {
    return deathMessageLongFall;
  }
  if (roomId === "room6_3" && doorType === "left") {
    return deathMessageFloat;
  }
  if (roomId === "room6_3" && doorType === "right") {
    return deathMessageMosquito;
  }
  if (roomId === "room4_1" && doorType === "right") {
    return deathMessageNoooo;
  }
  return null;
}

function triggerDeathScreen(message) {
  transitionState = "idle";
  if (activeVideo) {
    activeVideo.stop();
  }
  stopFakeEnding();
  stopEatMiceEnding();
  stopBecomeMiceEnding();
  midDoorFakegroundArmed = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  isDeathScreen = true;
  deathMessageText = message || deathMessageRib;
  currentBg = bgImg;
  nextRoom = null;
  transitionOrigin = null;
  deathMessageLayout();
}

function drawDeathScreen() {
  background(0);
  const time = millis() * 0.002;
  const flash = (sin(time) + 1) / 2;
  const jitter = sin(time * 3) * 2;
  const alpha = lerp(120, 255, flash);

  const shadowOffset = 2 + flash * 2;
  fill(0, alpha * 0.6);
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);
  textSize(24);
  text(deathMessageText, width / 2 + shadowOffset, height / 2 - 120 + jitter + shadowOffset);
  fill(255, alpha);
  text(deathMessageText, width / 2, height / 2 - 120 + jitter);

  deathMessageLayout();
  push();
  fill(255);
  noStroke();
  textSize(36);
  restartHover = isInsideRestart(mouseX, mouseY);
  const hoverFlash = (sin(millis() * 0.01) + 1) / 2;
  const scaleFactor = restartHover ? 1.2 : 1;
  drawingContext.save();
  drawingContext.translate(restartButton.x, restartButton.y);
  drawingContext.scale(scaleFactor, scaleFactor);
  const offset = 2 + hoverFlash * 2;
  drawingContext.fillStyle = `rgba(0,0,0,${0.5 + 0.4 * hoverFlash})`;
  drawingContext.font = "36px 'Times New Roman'";
  drawingContext.textAlign = "center";
  drawingContext.textBaseline = "middle";
  drawingContext.fillText("restart", offset, offset);
  drawingContext.fillStyle = "white";
  drawingContext.fillText("restart", 0, 0);
  drawingContext.restore();
  pop();
}

function layoutBurningRestartButton() {
  restartButton.x = width / 2;
  restartButton.y = height * 0.78;
  restartButton.w = width * 0.65;
  restartButton.h = 150;
}

function drawBurningRestartButton() {
  const time = millis();
  const jitterX = sin(time * 0.015) * 10;
  const jitterY = cos(time * 0.018) * 6;
  const scalePulse = 1.25 + 0.12 * sin(time * 0.04);
  const flare = (sin(time * 0.12) + 1) / 2;
  const textSizeBase = min(width, height) * 0.085;

  push();
  translate(restartButton.x + jitterX, restartButton.y + jitterY);
  scale(scalePulse);
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);

  for (let layer = 4; layer >= 1; layer--) {
    const alpha = 60 + layer * 35;
    const size = textSizeBase + layer * 10;
    fill(255, 120 + layer * 20, 0, alpha);
    textSize(size);
    text("restart", 0, 0);
  }

  const sparkle = 200 + flare * 55;
  fill(255, sparkle, 150);
  textSize(textSizeBase + 6);
  text("restart", 0, 0);
  pop();
}

function layoutFakeEndingRestartButton() {
  restartButton.x = width / 2;
  restartButton.y = height * 0.8;
  restartButton.w = width * 0.45;
  restartButton.h = 90;
}

function drawFakeEndingRestartButton() {
  const flicker = (sin(millis() * 0.02) + 1) / 2;
  push();
  translate(restartButton.x, restartButton.y);
  scale(1 + flicker * 0.06);
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);
  textSize(40 + flicker * 4);
  fill(0, 0, 0, 160);
  text("restart", 3, 3);
  fill(255, 255, 255, 230);
  text("restart", 0, 0);
  pop();
}

function startFakeEnding(type) {
  stopFakeEnding();
  stopEatMiceEnding();
  stopBecomeMiceEnding();
  midDoorFakegroundArmed = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  fakeEndingState = { type, video: fakeEndingVideos[type] || null, start: millis() };
  const vid = fakeEndingState.video;
  if (vid && fakeEndingReady[type]) {
    vid.time(0);
    vid.loop();
    vid.show();
  }
}

function stopFakeEnding() {
  if (fakeEndingState && fakeEndingState.video) {
    fakeEndingState.video.stop();
    fakeEndingState.video.hide();
  }
  fakeEndingState = null;
}

function returnFromFakeEnding() {
  if (fakeEndingState && fakeEndingState.video) {
    fakeEndingState.video.stop();
    fakeEndingState.video.hide();
  }
  fakeEndingState = null;
  stopBecomeMiceEnding();
  midDoorFakegroundArmed = false;
  currentRoom = "room3";
  currentBg = getRoomBaseBg(currentRoom);
  transitionState = "idle";
  activeVideo = null;
  activeDoorType = null;
  nextRoom = null;
  transitionOrigin = null;
  specialRoomStartTime = null;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  showOverlayMessage(FAKE_ENDING_RETURN_MESSAGE);
}

function layoutEatMiceRestartButton() {
  restartButton.x = width / 2;
  restartButton.y = height * 0.78;
  restartButton.w = width * 0.4;
  restartButton.h = 80;
}

function drawEatMiceRestartButton() {
  const pulse = (sin(millis() * 0.03) + 1) / 2;
  push();
  translate(restartButton.x, restartButton.y);
  scale(1 + pulse * 0.04);
  textFont("Times New Roman");
  textAlign(CENTER, CENTER);
  textSize(38);
  fill(0, 0, 0, 150);
  text("restart", 3, 3);
  fill(255, 255, 255, 230);
  text("restart", 0, 0);
  pop();
}

function startEatMiceEnding() {
  eatMiceEndingCount++;
  if (eatMiceEndingCount >= BECOME_MICE_THRESHOLD) {
    eatMiceEndingCount = 0;
    startBecomeMiceEnding();
    return;
  }
  stopFakeEnding();
  stopBecomeMiceEnding();
  stopEatMiceVideo();
  midDoorFakegroundArmed = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  eatMiceEndingState = { phase: eatMiceVideoReady ? "video" : "black" };
  if (eatMiceVideo && eatMiceVideoReady) {
    eatMiceVideo.time(0);
    eatMiceVideo.show();
    eatMiceVideo.play();
  }
}

function startBecomeMiceEnding() {
  stopFakeEnding();
  stopEatMiceEnding();
  midDoorFakegroundArmed = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  becomemiceEndingState = { active: true };
  if (becomemiceVideo && becomemiceVideoReady) {
    becomemiceVideo.time(0);
    becomemiceVideo.loop();
    becomemiceVideo.show();
  }
}

function stopEatMiceVideo() {
  if (eatMiceVideo) {
    eatMiceVideo.stop();
    eatMiceVideo.hide();
  }
}

function stopEatMiceEnding() {
  if (eatMiceEndingState) {
    stopEatMiceVideo();
  }
  eatMiceEndingState = null;
  sequentialDoorTransitions = 0;
}

function stopBecomeMiceEnding() {
  if (becomemiceEndingState && becomemiceVideo) {
    becomemiceVideo.stop();
    becomemiceVideo.hide();
  }
  becomemiceEndingState = null;
}

function deathMessageLayout() {
  restartButton.x = width / 2;
  restartButton.y = height / 2 + 40;
  restartButton.w = 320;
  restartButton.h = 70;
}

function isInsideRestart(mx, my) {
  const halfW = restartButton.w / 2;
  const halfH = restartButton.h / 2;
  return (
    mx >= restartButton.x - halfW &&
    mx <= restartButton.x + halfW &&
    my >= restartButton.y - halfH &&
    my <= restartButton.y + halfH
  );
}

function restartToRoom3() {
  isDeathScreen = false;
  deathMessageText = deathMessageRib;
  stopFakeEnding();
  stopEatMiceEnding();
  stopBecomeMiceEnding();
  midDoorFakegroundArmed = false;
  undefinedDoorStreak = 0;
  consecutiveNoEndingClicks = 0;
  sequentialDoorTransitions = 0;
  currentRoom = "room3";
  currentBg = getRoomBaseBg(currentRoom);
  transitionOrigin = null;
  activeVideo = null;
  activeDoorType = null;
  nextRoom = null;
  overlayMessage = null;
  specialRoomStartTime = null;
}

function drawIntroSequence() {
  if (introState === "video") {
    background(0);
    if (introVideoReady && introVideo) {
      drawVideoCover(introVideo);
    } else {
      drawCenteredParagraph(
        "Loading...",
        width / 2,
        height / 2,
        width * 0.4,
        80,
        18,
        255
      );
    }
    return;
  }

  if (introState === "black") {
    background(0);
    if (introBlackScreenStart && millis() - introBlackScreenStart > 2000) {
      startIntroDialogue();
    }
    return;
  }

  if (introState === "dialog") {
    background(0);
    const elapsed = millis() - (introDialogStart || 0);
    const reveal = constrain(elapsed / 1500, 0, 1);
    const alpha = 255 * reveal;
    drawCenteredParagraph(
      INTRO_DIALOGUES[introDialogIndex],
      width / 2,
      height / 2,
      width * 0.7,
      160,
      20,
      alpha
    );
    drawCenteredParagraph(
      "(click to continue)",
      width / 2,
      height * 0.78,
      width * 0.3,
      60,
      14,
      180 * reveal
    );
    return;
  }

  if (introState === "fade") {
    const t = constrain((millis() - introFadeStart) / 1500, 0, 1);
    drawRoom();
    drawFallingStars(currentRoom);
    drawDoors();
    fill(0, 255 * (1 - t));
    rect(0, 0, width, height);
    if (t >= 1) {
      finishIntro();
    }
  }
}

function handleIntroClick() {
  if (introState === "video") {
    if (introVideo) introVideo.stop();
    startIntroDialogue();
    return;
  }
  if (introState === "dialog") {
    introDialogIndex++;
    if (introDialogIndex >= INTRO_DIALOGUES.length) {
      startIntroFade();
    } else {
      introDialogStart = millis();
    }
  }
}

function startIntroDialogue() {
  if (introState === "dialog") return;
  introState = "dialog";
  introDialogIndex = 0;
  introDialogStart = millis();
  if (introVideo) {
    introVideo.stop();
    introVideo.hide();
  }
}

function startIntroFade() {
  introState = "fade";
  introFadeStart = millis();
}

function finishIntro() {
  introState = "done";
  if (introVideo) {
    introVideo.stop();
    introVideo.remove();
    introVideo = null;
  }
}
function drawRoomNarrative(roomId) {
  if (roomId !== "room4_2") return;
  const pulse = (sin(millis() * 0.0025) + 1) / 2;
  const alpha = lerp(160, 255, pulse);
  drawCenteredParagraph(
    "You felt a bit cold, you are not sure whether it's because you haven't eaten anything or that the air conditioner is broken... or... something is breathing cold air at your neck",
    width / 2,
    height / 2,
    width * 0.55,
    150,
    20,
    alpha
  );
}

function playDoorSound() {
  try {
    const audio = new Audio(DOOR_OPEN_SOUND);
    audio.volume = 0.8;
    audio.play().catch(() => {});
  } catch (err) {
    console.warn("Unable to play door sound", err);
  }
}

function handleSpecialRoomTimer() {
  if (currentRoom === SPECIAL_ROOM_ID && !isDeathScreen) {
    if (!specialRoomStartTime) {
      specialRoomStartTime = millis();
    } else if (millis() - specialRoomStartTime > 5000) {
      teleportOutOfSpecialRoom();
    }
  } else {
    specialRoomStartTime = null;
  }
}

function teleportOutOfSpecialRoom() {
  specialRoomStartTime = null;
  const candidates = Object.keys(rooms).filter(r => r !== SPECIAL_ROOM_ID);
  if (!candidates.length) return;
  const target = random(candidates);
  currentRoom = target;
  currentBg = getRoomBaseBg(currentRoom);
  transitionOrigin = null;
  showOverlayMessage(OVERLAY_TEXT);
}

function showOverlayMessage(text) {
  overlayMessage = {
    text,
    start: millis()
  };
}

function drawOverlayMessage() {
  if (!overlayMessage) return;
  const elapsed = millis() - overlayMessage.start;
  const total = OVERLAY_HOLD + OVERLAY_FADE * 2;
  if (elapsed >= total) {
    overlayMessage = null;
    return;
  }

  let alphaFactor = 1;
  if (elapsed < OVERLAY_FADE) {
    alphaFactor = easeOutQuad(elapsed / OVERLAY_FADE);
  } else if (elapsed > OVERLAY_HOLD + OVERLAY_FADE) {
    const t = (elapsed - OVERLAY_HOLD - OVERLAY_FADE) / OVERLAY_FADE;
    alphaFactor = 1 - easeInQuad(constrain(t, 0, 1));
  }

  const alpha = 255 * constrain(alphaFactor, 0, 1);
  drawCenteredParagraph(
    overlayMessage.text,
    width / 2,
    height / 2,
    width * 0.6,
    120,
    18,
    alpha
  );
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

function easeInQuad(t) {
  return t * t;
}

function drawVideoCover(videoEl) {
  const vidWidth = (videoEl && (videoEl.elt.videoWidth || videoEl.width)) || 1;
  const vidHeight = (videoEl && (videoEl.elt.videoHeight || videoEl.height)) || 1;
  const scale = max(width / vidWidth, height / vidHeight);
  const drawW = vidWidth * scale;
  const drawH = vidHeight * scale;
  const x = (width - drawW) / 2;
  const y = (height - drawH) / 2;
  image(videoEl, x, y, drawW, drawH);
}

function drawCenteredParagraph(str, cx, cy, boxWidth, boxHeight, fontSize, alpha) {
  push();
  textFont("Times New Roman");
  textAlign(LEFT, TOP);
  textSize(fontSize);
  textLeading(fontSize * 1.3);
  textWrap(WORD);

  const x = cx - boxWidth / 2;
  const y = cy - boxHeight / 2;
  const flicker = (sin(millis() * 0.01 + cx * 0.001) + 1) / 2;
  const offset = 2 + flicker * 2;
  fill(0, alpha * 0.6);
  text(str, x + offset, y + offset, boxWidth, boxHeight);
  fill(255, alpha);
  text(str, x, y, boxWidth, boxHeight);
  pop();
}

</script>
</body>
</html>
